# SSL(Secure Socker Layer)
- 보안 소켓 계층(Secure Socket Layer)은 넷스케이프사에서 개발한 인터넷 보안 프로토콜
#### 대칭키
대칭키는 동일한 키로 암호화와 복호화를 같이 할 수 있는 방식의 암호화 기법을 의미. 즉 암호화를 할 때 1234라는 값을 사용했다면 복호화를 할 때 1234라는 값을 입력해야 함.
#### 공개키
대칭키는 키를 암호를 주고 받는 사람들한테 전달하는 것이 어렵다. 대칭키가 유출되면 암호화가 아무런 의미가 없어진다. 이런 배경에서 공개키가 등장한다.

공개키 방식은 두개의 키를 갖게 되는데 A키를 암호화를 하면 B키로 복호화할 수 있고, B키로 암호화하면 A키로 복호화할 수 있는 방식이다. 이 방식에 착안해서 두개의 키 중 하나를 비공개키(private key, 개인키, 비밀키라고도 부릅니다)로 하고, 나머지를 공개키(public key)로 지정한다. 비공개키는 자신만이 가지고 있고, 공개키를 타인에게 제공한다. 공개키를 제공 받은 타인은 공개키를 이용해서 정보를 암호화한다. 암호화한 정보를 비공개키를 가지고 있는 사람에게 전송한다. 비공개키의 소유자는 이키를 이용해서 암호화된 정보를 복호화한다. 이 과정에서 공개키가 유출된다고해도 비공개키를 모르면 정보를 복호화할 수 없기 때문에 안전하다. 공개키로는 암호화할 수 있지만 복호화는 할 수 없기 때문이다.
### SSL 인증서
- 클라이언트와 서버간의 통신을 제3자가 보증해주는 전자화된 문서.
#### ssl 인증서의 역할
- 클라이언트가 접속한 서버가 신뢰할 수 있는 서버임을 보장함.
- ssl 통신에 사용할 공개키를 클라이언트에게 제공함.
#### ssl 동작원리
클라이언트와 서버가 주고받는 실제 정보는 대칭키 방식으로 암호화하고, 대칭키 방식으로 암호화된 실제 정보를 복호화할 때 사용할 대칭키는 공개키 방식으로 암호화해서 클라이언트와 서버가 주고 받게 된다. 즉, 실제 데이터는 대칭키이고 대칭키의 키는 공개키인 것이다.<br>
![image](https://user-images.githubusercontent.com/51396282/78525991-ab304300-7813-11ea-8b90-5d67ccd46422.png)<br>
##### 악수 (handshake)
실제 데이터를 주고 받기 전에 클라이언트와 서버는 일종의 인사인 Handshake를 한다. 이 과정을 통해서 서로 상대방이 존재하는지, 또 상대방과 데이터를 주고 받기 위해서는 어떤 방법을 사용해야 하는지를 파악한다. SSL 방식을 이용해서 통신을 하는 브라우저와 서버 역시 핸드쉐이크를 하는데, 이 때 SSL 인증서를 주고 받게된다.

공개키는 자원을 너무 많이 사용하고 대칭키는 보안에 약하다. 그래서 SSL은 공개키와 대칭키의 장점을 혼합한 방식을 사용한다.핸드쉐이크 단계에서 클라이언트와 서버가 통신하는 과정을 순서대로 살펴보면 다음과 같다.

1. 클라이언트가 서버에 접속.(client hello) 이 단계에서 주고 받는 정보는 아래와 같다.

>
>**클라이언트 측에서 생성한 랜덤 데이터**
>
>**클라이언트가 지원하는 암호화 방식들**: 클라이언트와 서버가 지원하는 암호화 방식이 서로 다를 수 있기 때문에 상호간에 어떤 암호화 방식을 사용할 것인지에 대한 협상을 해야 한다. 이 협상을 위해서 클라이언트 측에서는 자신이 사용할 수 있는 암호화 방식을 전송하게 된다.
>
>**세션 아이디**: 이미 SSL 핸드쉐이킹을 했다면 비용과 시간을 절약하기 위해서 기존의 세션을 재활용하게 되는데 이때 사용할 연결에 대한 식별자를 서버 측으로 전송한다.

2. 서버는 Client Hello에 대한 응답으로 Server Hello를 함. 이 단계에서 주고 받는 정보는 아래와 같다.

>**서버 측에서 생성한 랜덤 데이터**
>
>**서버가 선택한 클라이언트의 암호화 방식**: 클라이언트가 전달한 암호화 방식 중에서 서버 쪽에서도 사용할 수 있는 암호화 방식을 선택해서 클라이언트로 전달한다. 이로써 암호화 방식에 대한 협상이 종료되고 서버와 클라이언트는 이 암호화 방식을 이용해서 정보를 교환.
>
>**인증서**

3. 클라이언트는 서버의 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA 리스트를 확인한다. CA 리스트에 인증서가 없다면 사용자에게 경고 메시지를 출력. 인증서가 CA에 의해서 발급된 것인지를 확인하기 위해서 클라이언트에 내장된 CA의 공개키를 이용해서 인증서를 복호화한다. 복호화에 성공했다면 인증서는 CA의 개인키로 암호화된 문서임이 암시적으로 보증된 것임. 이러한 절차로 인증서를 전송한 서버를 신뢰할 수 있게 된다.<br>
클라이언트는 2번 단계를 통해서 받은 서버의 랜덤 데이터와 클라이언트가 생성한 랜덤 데이터를 조합해서 pre master secret이라는 키를 생성한다. 이 키는 뒤에서 살펴볼 세션 단계에서 데이터를 주고 받을 때 암호화하기 위해서 사용될 것이다. 이 때 사용할 암호화 기법은 대칭키이기 때문에 pre master secret 값은 제 3자에게 절대로 노출 되어서는 안 된다.<br>
이 pre master secret을 서버에 전달할 때 사용하는 방법이 바로 공개키 방식이다. 서버의 공개키로 pre master secret 값을 암호화해서 서버로 전송하면 서버는 자신의 비공개키로 안전하게 복호화 할 수 있다. 그럼 서버의 공개키를 어떻게 구할 수 있었을까? server hello 단계에서 서버로부터 받은 인증서 안에 들어있다. 이 서버의 공개키를 이용해서 pre master secret 값을 암호화한 후에 서버로 전송하면 안전하게 전송할 수 있다.<br>
<br>
4. 서버는 클라이언트가 전송한 pre master secret 값을 자신의 비공개키로 복호화한다. 이로서 서버와 클라이언트가 모두 pre master secret 값을 공유하게 되었다. 그리고 서버와 클라이언트는 모두 일련의 과정을 거쳐서  pre master secret 값을 master secret 값으로 만든다. master secert 은 session key를 생성하는데 이 session key 값을 이용해서 서버와 클라이언트는 데이터를 대칭키 방식으로 암호화한 후에 주고 받게 된다. 이렇게해서 세션키를 클라이언트와 서버가 모두 공유하게 된다.

5. 클라이언트와 서버는 핸드쉐이크 단계의 종료를 서로에게 알린다.

##### 세션
세션은 실제로 서버와 클라이언트가 데이터를 주고받는 단계. 이 단계에서 핵심은 정보를 상대방에게 전송하기 전에 session key 값을 이용해서 대칭키 방식으로 암호화 한다는 점이다. 암호화된 정보는 상대방에게 전송될 것이고, 상대방도 세션키 값을 알고 있기 때문에 암호를 복호화 할 수 있다.

###### 세션 종료
데이터의 전송이 끝나면 SSL 통신이 끝났음을 서로에게 알려준다. 이 때 통신에서 사용한 대칭키인 세션키를 폐기한다.

##### [출처] (https://12bme.tistory.com/80)
